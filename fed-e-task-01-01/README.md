### 第一题
最终执行结果为：打印出 10。

原因是:
变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。
每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，
里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。

### 第二题

原因是:
存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。

### 第三题
答案是:
```javascript
    var arr = [12,34,32,89,4];
    console.log(Math.min(...arr)); //4
```
### 第四题 请详细说明 var，let，const 三种声明变量的方式之间的具体差别？
- var
    1.var表示声明了一个变量,并且可以同时初始化该变量.
    2.使用var语句声明的变量的作用域是当前执行位置的上下文:一个函数的内部(声明在函数内)或者全局(声明在函数外).
    3.var变量提升:由于变量声明(以及其他声明)总是在任意代码执行之前处理的,所以在代码中的任意位置声明变量总是等效于在代码开头声明.这意味着变量可以在声明之前使用
 - let
    1.let声明了一个块级域的局部变量,并且可以给它一个初始化值.
    2.let允许把变量的作用域限制在块级域中.与var不同处是:var声明变量要么是全局的,要么是函数级的,而无法是块级的.
    3.let声明的变量作用域包含定义它的块以及任何包含的子块中.这点和var相似.
    4.在同一个函数或同一个作用域中用let重复定义一个变量将引起TypeError.
    5.let的作用域是块,而var的作用域是函数.
    6.let块提供了一种在块的范围内获取变量的值,而不会影响块外面名字相同的变量的值的方法.

 - const
    1.const声明创建一个只读的常量.这不意味着常量指向的值不可变,而是变量标志符的值只能赋值一次.
    2.可以在全局作用域或者函数内声明常量,常量需要被初始化.
    3.常量拥有块作用域,和使用let定义的变量十分相似.常量的值不能通过再赋值改变,也不能再次声明.
    4.一个常量不能和它所在相同作用域内的其他变量或函数拥有相同的名称.
    5.常量可以是一个具体的值,也可以是一个对象.注意:常量是对象时,对象内部的属性可变而不受保护.

### 第五题
最终执行结果为：打印20

原因是:
setTimeout的参数是一个箭头函数，
这个箭头函数的定义生效是在obj对象内，如果是普通函数，执行时this应该指向全局对象window，
这时应该输出10。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 20}），所以输出的是20。
箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域

### 第六题
ES5 的对象属性名都是字符串，这容易造成属性名的冲突。
例如,在使用了他人提供的对象,但是又想为这个对象添加新的方法,
新方法的名字就有可能与现有方法产生冲突。如果有一种机制，
保证每个属性的名字都是独一无二的就好了，这就是 ES6 引入Symbol的原因。
### 第七题
浅拷贝只是增加了一个指针指向已经存在的内存，
而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存
### 第八题
 - js异步编程
JS是一门单线程的语言，即代码只会一行一行的执行，假如中间执行函数需要等待五秒，那么就会阻塞进程，为了解决这个问题，就出现了异步编程
JS引擎会将程序分为同步任务和异步任务，只有当同步任务完成之后，才会去执行异步任务，异步任务即将来再完成的任务。
通常处理异步操作我们经历了以下进程，从一开始的回调方式，再到Promise，再到Generator，再到async/await，因为asyinc/await本质上是Generator的语法糖

 - js宏任务,微任务,事件循环
javaScript 中的任务可以被划分为宏任务（Macrotask）或者微任务（Microtask）。

像鼠标事件，键盘事件,"ajax","setTimeout"等就属于宏任务，需要注意的是，主线程的整体代码(script标签)，也是一个宏任
process.nextTick，PromiseA.then()， MutaionObserver 就属于微任务

事件循环，就是
1.执行宏任务队列中第一个任务，执行完后移除它
2.执行所有的微任务，执行完后移除它们
3.执行下一轮宏任务（重复步骤2）
如此循环就形成了event loop，其中，每轮执行一个宏任务和所有的微任务
### 第九题
优化之后的代码
```javascript

    function timeoutFn(data) {
        return new Promise((resolve,reject) => {
            setTimeout(() => {
                resolve(data)
            },10)
        })
    }

    timeoutFn().then(_ => {
        var a = 'hello';
        return timeoutFn(a)
    }).then(a => {
        var b = 'lagou'
        return timeoutFn({a,b})
    }).then(({a,b}) => {
        var c = "i love you"
        console.log(a+b+c);
    })
```
### 第十题
TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持    
### 第十一题
 - Typescript 的优点

主要是TypeScript 增加了代码的可读性和可维护性
1.增加函数的可读性,大部分的函数看类型的定义就知道做什么
2.可以在编译阶段就发现大部分错误
3.增强了编辑器和 IDE 的功能
4.TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可
5. 即使不显式的定义类型，也能够自动做出[类型推论]()
6.TypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范

 - TypeScript 的缺点

1.有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等概念
2.短期可能会增加一些开发成本，毕竟要多写一些类型的定义
3.集成到构建流程需要一些工作量
4.一下三方库没有提供类型声明文件